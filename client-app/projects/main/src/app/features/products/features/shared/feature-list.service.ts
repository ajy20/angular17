import { HttpClient, HttpHeaders } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { BehaviorSubject, Observable, of } from 'rxjs';
import { map, mergeMap, tap } from 'rxjs/operators';
import { VersionPageService } from '../../shared/components/version-page-template/services/version-page.service';
import { FeatureListVersion } from './models/feature-list-version.model';
import { FeatureListVersionComparison } from '../../shared/components/feature-comparer/models/feature-list-version-comparison.model';
import { FeatureFactoryList } from './models/feature-factory-list.model';
import { FeatureRuleSet } from './models/feature-ruleset.model';
import { BaseDocument } from '../../shared/components/version-page-template/models/document.model';
import { constants } from '../../../../shared/constants/constants';

const httpOptions = {
  headers: new HttpHeaders({ 'Content-Type': 'application/json' })
};

@Injectable({
  providedIn: 'root'
})
export class FeatureListService extends VersionPageService<FeatureListVersion, FeatureListVersionComparison> {
  // Factories
  factoryList$: BehaviorSubject<FeatureFactoryList | null> = new BehaviorSubject<FeatureFactoryList | null>(null);

  // The list of rules
  ruleSet$: BehaviorSubject<FeatureRuleSet | null> = new BehaviorSubject<FeatureRuleSet | null>(null);

  constructor(protected override http: HttpClient) {
    super(http, 'product-feature-list')
  }

  clearData() {
    this.version$.next(null);
    this.factoryList$.next(null);
  }

  getFeatureListDocumentByProductId(productId: string): Observable<BaseDocument | null> {
    return this.getDocumentByProductId<BaseDocument>(productId);
  }

  getFeatureListVersion(id: string): Observable<FeatureListVersion | null> {
    return this.getVersion(id);
  }

  getImportableFeatureListVersion(id: string): Observable<FeatureListVersion | null> {
    return this.getImportableVersion(id);
  }

  // Get factories for the feature list version (from feature list version id)
  getFactories(id: string): Observable<FeatureFactoryList | null> {
    // Compute the version Id
    const computedId = this.computeVersionId(id);

    if (!computedId)
      return of(null).pipe(tap(x => { this.factoryList$.next(null); }));

    const url = `${this.versionUrl}/${computedId}/factories`;
    return this.http.get<FeatureFactoryList>(url).pipe(tap(x => {
      this.factoryList$.next(x);
    }));
  }

  // Get ruleset for the screen version
  getRuleSet(id: string): Observable<FeatureRuleSet | null> {
    // Compute the version Id
    const computedId = this.computeVersionId(id);

    if (!computedId)
      return of(null).pipe(tap(x => { this.ruleSet$.next(null); }));

    const url = `${this.versionUrl}/${computedId}/rules`;
    return this.http.get<FeatureRuleSet>(url).pipe(tap(x => {
      this.ruleSet$.next(x);
    }));
  }

  // Add Features
  addFeatures(id: string, features: { name: string, description: string, category: string, dimensionId: string, isNumeric: boolean, isFreeText: boolean, isArray: boolean, rank: string, isAutoGenerated: boolean }[]): Observable<any> {
    const url = `${this.versionUrl}/${id}/features/add-multiple`;
    const payload = { features };

    return this.http.post(url, payload, httpOptions).pipe(
      map((ids: any) => features.map((f, i) => ({ ...f, id: ids[i], options: [], styleRestrictions: [], notes: '', category: { name: f.category.toUpperCase() }, arraySize: { featureId: constants.emptyGuid, size: 0 } }))),
      // Add all features to current feature list version
      tap(feats => {
        const version = this.version$.getValue();
        if (version) {
          version.features = version.features || [];
          version.features.push(...feats)
          this.version$.next(version);
        }
      }),
      // Create default option for numeric features
      mergeMap(feats => {
        const numericFeatures = feats.filter(f => f.isNumeric);
        const numericOptions = numericFeatures.map(f => ({ featureId: f.id, name: 'NUM', description: 'Numeric value', rank: 'aaa', isAutoGenerated: true }));
        const freeTextFeatures = feats.filter(f => f.isFreeText);
        const freeTextOptions = freeTextFeatures.map(f => ({ featureId: f.id, name: 'TXT', description: 'Free Text', rank: 'aaa', isAutoGenerated: true }));
        const optionsToCreate = [...numericOptions, ...freeTextOptions];
        return optionsToCreate.length ? this.addOptions(id, optionsToCreate).pipe(map(() => feats)) : of(feats);
      })
    )
  }

  // Move a feature
  moveFeature(id: string, featureId: string, rank: string): Observable<any> {
    const url = `${this.versionUrl}/${id}/features/${featureId}/move`;
    const payload = { rank };
    return this.http.post(url, payload, httpOptions).pipe(tap(x => {
      const version = this.version$.getValue();
      const feature = version?.features?.find(s => s.id === featureId);
      if (feature) {
        feature.rank = rank;
        this.version$.next(version);
      }
    }));
  }

  // Delete features
  deleteFeatures(id: string, featureIds: string[]): Observable<any> {
    const url = `${this.versionUrl}/${id}/features/remove-multiple`;
    const payload = { ids: featureIds };
    return this.http.post(url, payload, httpOptions).pipe(tap(x => {
      const version = this.version$.getValue();
      if (version)
        version.features = version.features.filter(f => !featureIds.includes(f.id))
      this.version$.next(version);
    }));
  }

  // Update a feature
  updateFeature(id: string, featureId: string, name: string, description: string, notes: string, categoryName: string, arraySizeFeatureId: string, size: number): Observable<any> {
    const url = `${this.versionUrl}/${id}/features/${featureId}/update-properties`;
    const payload = { name, description, notes, categoryName, arraySizeFeatureId, size: isNaN(size) ? 0 : size };
    return this.http.post(url, payload, httpOptions).pipe(tap(x => {
      const version = this.version$.getValue();
      const feature = version?.features?.find(s => s.id === featureId);
      if (feature) {
        if (name?.length)
          feature.name = name;

        if (description?.length)
          feature.description = description;

        if (notes?.length)
          feature.notes = notes;

        if (categoryName?.length)
          feature.category.name = categoryName.toUpperCase();

        if (arraySizeFeatureId !== constants.emptyGuid && feature.arraySize) {
          feature.arraySize.featureId = arraySizeFeatureId;
          feature.arraySize.size = 0;
        }

        if (size > 0 && arraySizeFeatureId === constants.emptyGuid && feature.arraySize) {
          feature.arraySize.size = size;
          feature.arraySize.featureId = constants.emptyGuid;
        }

        this.version$.next(version);
      }
    }));
  }

  // Update style restriction
  updateStyleRestriction(id: string, featureId: string, styleIds: any): Observable<any> {
    const url = `${this.versionUrl}/${id}/features/${featureId}/update-style-restrictions`;
    const payload = { styleIds };
    return this.http.post(url, payload, httpOptions).pipe(tap(x => {
      const version = this.version$.getValue();
      const feature = version?.features?.find(s => s.id === featureId);
      if (feature) {
        feature.styleRestrictions = styleIds;

        this.version$.next(version);
      }
    }));
  }

  // Options ----------
  addOptions(id: string, options: { featureId: string, name: string, description: string, rank: string, isAutoGenerated: boolean }[]): Observable<any> {
    const url = `${this.versionUrl}/${id}/options/add-multiple`;
    const payload = { options };
    return this.http.post(url, payload, httpOptions).pipe(tap((ids: any) => {
      const version = this.version$.getValue();
      if (version) {
        options.forEach((o, i) => {
          const feature = version.features?.find(s => s.id === o.featureId);
          if (feature) {
            feature.options = feature.options || [];
            feature.options.push({ ...o, id: ids[i], isActive: false, releases: [] });
          }
        });
        this.version$.next(version);
      }
    }));
  }

  moveOption(id: string, featureId: string, optionId: string, rank: string): Observable<any> {
    const url = `${this.versionUrl}/${id}/options/${optionId}/move`;
    const payload = { rank };
    return this.http.post(url, payload, httpOptions).pipe(tap(x => {
      const version = this.version$.getValue();
      const feature = version?.features?.find(s => s.id === featureId);
      const option = feature?.options?.find(s => s.id === optionId);
      if (option) {
        option.rank = rank;
        this.version$.next(version);
      }
    }));
  }

  deleteOptions(id: string, options: { featureId: string, optionId: string }[]): Observable<any> {
    const ids = options.map(o => o.optionId);
    const url = `${this.versionUrl}/${id}/options/remove-multiple`;
    const payload = { ids };
    return this.http.post(url, payload, httpOptions).pipe(tap(x => {
      const version = this.version$.getValue();
      if (version) {
        options.forEach(o => {
          const feature = version.features?.find(s => s.id === o.featureId);
          if (feature)
            feature.options = feature.options.filter(x => x.id !== o.optionId);
        });
        this.version$.next(version);
      }
    }));
  }

  updateOption(id: string, featureId: string, optionId: string, name: string, description: string): Observable<any> {
    const url = `${this.versionUrl}/${id}/options/${optionId}/update-properties`;
    const payload = { name, description };
    return this.http.post(url, payload, httpOptions).pipe(tap(x => {
      const version = this.version$.getValue();
      const feature = version?.features?.find(s => s.id === featureId);
      const option = feature?.options?.find(s => s.id === optionId);
      if (option) {
        if (name?.length)
          option.name = name;

        if (description?.length)
          option.description = description;

        this.version$.next(version);
      }
    }));
  }

  activateOptions(id: string, options: { featureId: string, optionId: string }[]): Observable<any> {
    const ids = options.map(o => o.optionId);
    const url = `${this.versionUrl}/${id}/options/activate-multiple`;
    const payload = { ids };
    return this.http.post(url, payload, httpOptions).pipe(tap(x => {
      const version = this.version$.getValue();
      if (version) {
        options.forEach(o => {
          const feature = version.features?.find(s => s.id === o.featureId);
          const option = feature?.options?.find(s => s.id === o.optionId);
          if (option) {
            option.isActive = true;
          }
        });
        this.version$.next(version);
      }
    }));
  }

  deactivateOptions(id: string, options: { featureId: string, optionId: string }[]): Observable<any> {
    const ids = options.map(o => o.optionId);
    const url = `${this.versionUrl}/${id}/options/deactivate-multiple`;
    const payload = { ids };
    return this.http.post(url, payload, httpOptions).pipe(tap(x => {
      const version = this.version$.getValue();
      if (version) {
        options.forEach(o => {
          const feature = version.features?.find(s => s.id === o.featureId);
          const option = feature?.options?.find(s => s.id === o.optionId);
          if (option) {
            option.isActive = false;
            option.releases = [];
          }
        });
        this.version$.next(version);
      }
    }));
  }

  releaseOptionsToFactory(id: string, options: { featureId: string, optionId: string, asSQ: boolean }[], factoryId: string) {
    const url = `${this.versionUrl}/${id}/options/release-multiple`;
    const payload = { options, factoryId };
    return this.http.post(url, payload, httpOptions).pipe(tap(x => {
      const version = this.version$.getValue();
      if (version) {
        options.forEach(o => {
          const feature = version.features?.find(s => s.id === o.featureId);
          const option = feature?.options?.find(s => s.id === o.optionId);
          if (option)
            option.releases.push({ factoryId, asSQ: o.asSQ });
        });
        this.version$.next(version);
      }
    }));
  }

  unreleaseFeatureOptionsFromFactory(id: string, options: { featureId: string, optionId: string }[], factoryId: string): Observable<any> {
    const optionIds = options.map(o => o.optionId);
    const url = `${this.versionUrl}/${id}/options/unrelease-multiple`;
    const payload = { optionIds, factoryId };
    return this.http.post(url, payload, httpOptions).pipe(tap(x => {
      const version = this.version$.getValue();
      if (version) {
        options.forEach(o => {
          const feature = version.features?.find(s => s.id === o.featureId);
          const option = feature?.options?.find(s => s.id === o.optionId);
          if (option)
            option.releases = option.releases.filter(r => r.factoryId !== factoryId);
        });
        this.version$.next(version);
      }
    }));
  }

  updateOptionReleaseSqRules(id: string, featureId: string, optionId: string, factoryId: string, rules: string[][]): Observable<any> {
    const url = `${this.versionUrl}/${id}/options/${optionId}/update-sq-rules`;
    const payload = { factoryId, rules };
    return this.http.post(url, payload, httpOptions).pipe(tap(x => {
      const version = this.version$.getValue();
      const feature = version?.features?.find(s => s.id === featureId);
      const option = feature?.options?.find(s => s.id === optionId);
      if (option) {
        const release = option.releases?.find(r => r.factoryId === factoryId);
        if (release)
          release.sqRules = rules?.length ? { rules: rules } : undefined;
        this.version$.next(version);
      }
    }));
  }

  updateOptionReleaseUnavailableRules(id: string, featureId: string, optionId: string, factoryId: string, rules: string[][]): Observable<any> {
    const url = `${this.versionUrl}/${id}/options/${optionId}/update-unavailable-rules`;
    const payload = { factoryId, rules };
    return this.http.post(url, payload, httpOptions).pipe(tap(x => {
      const version = this.version$.getValue();
      const feature = version?.features?.find(s => s.id === featureId);
      const option = feature?.options?.find(s => s.id === optionId);
      if (option) {
        const release = option.releases?.find(r => r.factoryId === factoryId);
        if (release)
          release.unavailableRules = rules?.length ? { rules: rules } : undefined;
        this.version$.next(version);
      }
    }));
  }

  updateOptionReleaseContractRules(id: string, featureId: string, optionId: string, factoryId: string, rules: string[][]): Observable<any> {
    const url = `${this.versionUrl}/${id}/options/${optionId}/update-contract-rules`;
    const payload = { factoryId, rules };
    return this.http.post(url, payload, httpOptions).pipe(tap(x => {
      const version = this.version$.getValue();
      const feature = version?.features?.find(s => s.id === featureId);
      const option = feature?.options?.find(s => s.id === optionId);
      if (option) {
        const release = option.releases?.find(r => r.factoryId === factoryId);
        if (release)
          release.contractRules = rules?.length ? { rules: rules } : undefined;
        this.version$.next(version);
      }
    }));
  }

  // Add multiple features and options to a feature list version
  addFeaturesAndOptions(id: string,
    features: { name: string, description: string, category: string, dimensionId: string, isNumeric: boolean, isFreeText: boolean, isArray: boolean, rank: string }[],
    options: { featureName: string, name: string, description: string, rank: string }[]): Observable<any> {
    // Url and payload for features
    const featuresUrl = `${this.versionUrl}/${id}/features/add-multiple`;
    const featuresPayload = { features };

    // Url and payload for options
    const optionsUrl = `${this.versionUrl}/${id}/options/add-multiple`;

    return this.http.post(featuresUrl, featuresPayload, httpOptions).pipe(
      map((ids: any) => features.map((f, i) => ({ ...f, id: ids[i], options: [], styleRestrictions: [], notes: '', category: { name: f.category.toUpperCase() }, arraySize: { featureId: constants.emptyGuid, size: 0 }, isAutoGenerated: false }))),
      // Add all features to current feature list version
      tap(feats => {
        const version = this.version$.getValue();
        if (version) {
          version.features = version.features || [];
          version.features.push(...feats);
          this.version$.next(version);
        }
      }),
      // Create default option for numeric features
      mergeMap(feats => {
        // Auto-generated options
        const numericFeatures = feats.filter(f => f.isNumeric);
        const numericOptions = numericFeatures.map(f => ({ featureId: f.id, name: 'NUM', description: 'Numeric value', rank: 'aaa', isAutoGenerated: true, featureName: f.name }));
        const freeTextFeatures = feats.filter(f => f.isFreeText);
        const freeTextOptions = freeTextFeatures.map(f => ({ featureId: f.id, name: 'TXT', description: 'Free Text', rank: 'aaa', isAutoGenerated: true, featureName: f.name }));

        // Update options from input with features ids
        const inputOptions = options.map(o => ({
          ...o,
          featureId: feats.find(y => y.name === o.featureName)?.id,
          isAutoGenerated: false
        }));

        // Merge auto-generated and input options and create
        const optionsToCreate = [...numericOptions, ...freeTextOptions, ...inputOptions];

        if (optionsToCreate.length) {
          return this.http.post(optionsUrl, { options: optionsToCreate }, httpOptions).pipe(
            tap((ids: any) => {
              const version = this.version$.getValue();
              if (version) {
                optionsToCreate.forEach((o, i) => {
                  const feature = version.features?.find(s => s.id === o.featureId);
                  if (feature) {
                    feature.options = feature.options || [];
                    feature.options.push({ ...o, id: ids[i], featureId: feature.id, isActive: false, releases: [] });
                  }
                });
                this.version$.next(version);
              }
            }),
            map(() => feats)
          )
        }
        else return of(feats);
      })
    );
  }

  getAllProductsReleasedFeaturesAndOptions(): Observable<FeatureListVersion[]> {
    return this.http.get<FeatureListVersion[]>(this.versionUrl, httpOptions);
  }
}
